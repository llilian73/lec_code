# 为什么时间戳不同会导致能耗计算结果不同？

## 核心原因

时间戳差异会影响能耗计算的**三个关键环节**：

### 1. 时间序列平滑计算（`smooth_temperature`）

**位置**: `demand_ninja/util.py` 第4-33行

```python
def smooth_temperature(temperature: pd.Series, weights: list) -> pd.Series:
    lag = temperature.copy()
    smooth = temperature.copy()
    
    for w in weights:
        # 关键：使用 shift(1) 获取前一天的数据
        lag = lag.shift(1, fill_value=lag.iloc[0])
        smooth = (smooth + (lag * w)).reindex()
```

**影响机制**:
- `shift(1)` 依赖于**时间索引的顺序和连续性**
- 如果时间戳不连续或格式不一致，`shift(1)` 可能无法正确找到"前一天"
- 这会导致平滑计算的结果不同

**示例**:
```python
# 文件1：使用实际时间戳
index1 = pd.DatetimeIndex(['2030-07-01 12:00:00', '2030-07-02 12:00:00', ...])
# shift(1) 能正确找到前一天

# 文件2：使用生成的连续日期
index2 = pd.DatetimeIndex(['2030-07-01 00:00:00', '2030-07-02 00:00:00', ...])
# 如果原始数据的时间戳是 12:00:00，shift(1) 可能无法正确对齐
```

### 2. 时间索引修改和插值（`demand_p` 函数）

**位置**: `demand_ninja/core_p.py` 第178-197行

```python
def demand_p(daily_bait: pd.Series, ...):
    # 第178行：修改时间索引，加12小时
    daily_bait.index = pd.date_range(
        daily_bait.index[0] + pd.Timedelta("12h"),  # 关键：基于第一个时间戳
        daily_bait.index[-1] + pd.Timedelta("12h"),
        freq="1D",
    )
    
    # 第185-192行：创建小时级索引
    hourly_bait = pd.Series(
        index=pd.date_range(
            start=daily_bait.index[0].replace(hour=0, minute=0, second=0),  # 关键
            end=daily_bait.index[-1].replace(hour=23, minute=59, second=59),
            freq="1h",
        ),
        dtype=float,
    )
    
    # 第195行：插值
    hourly_bait = daily_bait.reindex(hourly_bait.index).interpolate(
        method="cubicspline", limit_direction="both"
    )
```

**影响机制**:

#### 问题1：起始时间不同
- 如果 `daily_bait.index[0]` 是 `2030-07-01 12:00:00`（文件1）
  - 第178行：`2030-07-01 12:00:00 + 12h = 2030-07-02 00:00:00`
  - 第187行：`2030-07-02 00:00:00` 开始插值

- 如果 `daily_bait.index[0]` 是 `2030-07-01 00:00:00`（文件2）
  - 第178行：`2030-07-01 00:00:00 + 12h = 2030-07-01 12:00:00`
  - 第187行：`2030-07-01 00:00:00` 开始插值

**结果**: 插值的时间范围不同，导致小时级数据不同！

#### 问题2：边界处理
- `interpolate(method="cubicspline", limit_direction="both")` 在边界处的行为依赖于时间索引
- 不同的起始时间会导致边界插值结果不同

### 3. 数据对齐问题

**位置**: `calculate_energy_demand` 函数中

```python
# 文件1和文件2都有这段代码（第265-270行）
daily_bait = bait.copy()
daily_bait.index = pd.date_range(
    start=daily_bait.index[0],  # 关键：基于原始索引的第一个值
    end=daily_bait.index[-1],
    freq='D'
)
```

**影响机制**:
- 如果 `bait.index[0]` 不同（因为 `weather_df.index` 不同），生成的 `daily_bait.index` 也会不同
- 这进一步影响 `demand_p` 函数中的时间索引修改

## 具体示例

假设有一个3天的热浪事件（7月1-3日）：

### 文件1（使用实际时间戳）
```python
# NetCDF文件中的时间戳可能是：12:00:00
weather_df.index = [
    '2030-07-01 12:00:00',
    '2030-07-02 12:00:00', 
    '2030-07-03 12:00:00'
]

# 计算BAIT后
bait.index = [
    '2030-07-01 12:00:00',
    '2030-07-02 12:00:00',
    '2030-07-03 12:00:00'
]

# 修改为每日索引
daily_bait.index = [
    '2030-07-01 00:00:00',
    '2030-07-02 00:00:00',
    '2030-07-03 00:00:00'
]

# demand_p 函数中加12小时
daily_bait.index = [
    '2030-07-01 12:00:00',
    '2030-07-02 12:00:00',
    '2030-07-03 12:00:00'
]

# 创建小时级索引（从第一个日期的0点开始）
hourly_index = [
    '2030-07-01 00:00:00',
    '2030-07-01 01:00:00',
    ...
    '2030-07-03 23:00:00'
]
```

### 文件2（使用生成的连续日期）
```python
# 生成的连续日期：00:00:00
weather_df.index = [
    '2030-07-01 00:00:00',
    '2030-07-02 00:00:00',
    '2030-07-03 00:00:00'
]

# 计算BAIT后
bait.index = [
    '2030-07-01 00:00:00',
    '2030-07-02 00:00:00',
    '2030-07-03 00:00:00'
]

# 修改为每日索引（已经是00:00:00，所以不变）
daily_bait.index = [
    '2030-07-01 00:00:00',
    '2030-07-02 00:00:00',
    '2030-07-03 00:00:00'
]

# demand_p 函数中加12小时
daily_bait.index = [
    '2030-07-01 12:00:00',
    '2030-07-02 12:00:00',
    '2030-07-03 12:00:00'
]

# 创建小时级索引（从第一个日期的0点开始）
hourly_index = [
    '2030-07-01 00:00:00',  # 注意：这里和文件1相同
    '2030-07-01 01:00:00',
    ...
    '2030-07-03 23:00:00'
]
```

**但是！** 如果NetCDF文件中的实际时间戳不是00:00:00，而是12:00:00，那么：

- **文件1**: 使用实际时间戳12:00:00，数据对齐正确
- **文件2**: 使用生成的00:00:00，但实际数据是12:00:00的，导致**数据错位12小时**！

## 数据错位的具体影响

### 场景：NetCDF时间戳是12:00:00，但文件2生成了00:00:00的索引

```python
# 文件2的情况
weather_df.index = ['2030-07-01 00:00:00', '2030-07-02 00:00:00', ...]
# 但实际数据对应的时间是：
# '2030-07-01 00:00:00' -> 实际应该是 7月1日12:00的数据
# '2030-07-02 00:00:00' -> 实际应该是 7月2日12:00的数据

# 这导致：
# 1. 数据与时间戳不匹配
# 2. smooth_temperature 的 shift(1) 可能无法正确找到前一天
# 3. 插值时的时间范围计算错误
```

## 为什么这会导致能耗不同？

1. **BAIT值不同**: 时间对齐错误导致温度、辐射等数据与时间戳不匹配，BAIT计算错误
2. **平滑结果不同**: `smooth_temperature` 依赖正确的时间顺序，错位导致平滑结果不同
3. **插值结果不同**: 不同的时间范围导致小时级插值结果不同
4. **能耗计算不同**: 最终的小时级能耗 = f(BAIT, 阈值, 人口)，BAIT不同导致能耗不同

## 解决方案

**统一使用实际时间戳**（推荐）：

```python
def load_climate_data(lat, lon, start_date, duration, climate_data):
    duration = int(duration)
    end_date = start_date + timedelta(days=duration - 1)
    
    # 获取数据
    data = climate_data.get_data(lat, lon, start_date, end_date)
    
    # 获取实际的时间索引（而不是生成新的）
    start_np = np.datetime64(start_date.strftime('%Y-%m-%dT12:00:00'))
    end_np = np.datetime64(end_date.strftime('%Y-%m-%dT12:00:00'))
    time_mask = (climate_data.time_index_year >= start_np) & (climate_data.time_index_year <= end_np)
    actual_time_index = climate_data.time_index_year[time_mask]
    
    # 使用实际时间戳作为索引
    weather_df = pd.DataFrame(data, index=actual_time_index)
    return weather_df
```

这样可以确保：
1. 时间戳与数据完全匹配
2. `smooth_temperature` 能正确找到前一天的数据
3. `demand_p` 函数中的时间索引修改基于正确的时间戳
4. 插值的时间范围正确

## 总结

时间戳不同导致结果不同的根本原因是：
1. **数据对齐错误**: 时间戳与数据不匹配
2. **时间序列计算错误**: `shift(1)` 等操作无法正确工作
3. **插值范围错误**: 不同的起始时间导致插值结果不同

**关键点**: 必须使用NetCDF文件中的**实际时间戳**，而不是生成的连续日期！

