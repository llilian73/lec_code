# 两个能耗计算代码的对比分析

## 文件对比
1. `code/heat_wave/4_energy/2_energy_last_for_all_hw_test_1_point.py`
2. `code/heat_wave/data/energy_last_for_all_hw_test_1_point.py`

## 关键差异分析

### 1. 气候数据加载方式（最重要）

#### 文件1 (`2_energy_last_for_all_hw_test_1_point.py`)
- **方法**: `load_climate_data_for_period(lat, lon, start_date, end_date)`
- **特点**: 
  - 每次热浪事件都**重新打开NetCDF文件**
  - 每次都要筛选2030年的数据
  - 然后筛选指定时间段的数据
- **代码位置**: 第104-176行

```python
def load_climate_data_for_period(lat, lon, start_date, end_date):
    # 每次循环都打开文件
    with xr.open_dataset(file_path) as ds:
        # 筛选2030年
        year_mask = time_index.year == TARGET_YEAR
        point_data_2030 = point_data.isel(time=np.where(year_mask)[0])
        # 筛选时间段
        time_mask = (time_index_2030 >= start_date) & (time_index_2030 <= end_date)
        # 使用实际时间戳作为索引
        weather_df = pd.DataFrame({...}, index=climate_data['tas']['time'])
```

#### 文件2 (`energy_last_for_all_hw_test_1_point.py`)
- **方法**: `ClimateData` 类 + `load_climate_data()`
- **特点**:
  - **预先加载**整个2030年的数据到内存（`ClimateData.__init__`）
  - 后续从内存中筛选时间段
  - 使用生成的连续日期作为索引
- **代码位置**: 第90-236行

```python
class ClimateData:
    def __init__(self, climate_dir, year):
        # 预先加载整个2030年的数据
        year_data = ds_var[var_name].isel(time=year_mask).load()
        self.data[var_name] = year_data.values
        self.time_index_year = self.time_index[year_mask]

def load_climate_data(lat, lon, start_date, duration, climate_data):
    # 从内存中获取数据
    data = climate_data.get_data(lat, lon, start_date, end_date)
    # 使用生成的连续日期作为索引
    index = pd.date_range(start=start_date, periods=len(data['temperature']), freq='D')
    weather_df = pd.DataFrame(data, index=index)
```

### 2. DataFrame索引创建方式（关键差异）

#### 文件1: 使用实际时间戳
```python
# 第174行
weather_df = pd.DataFrame({...}, index=climate_data['tas']['time'])
```
- **优点**: 使用NetCDF文件中的**实际时间戳**，更准确
- **特点**: 时间戳可能包含具体的时间（如12:00:00）

#### 文件2: 使用生成的连续日期
```python
# 第233行
index = pd.date_range(start=start_date, periods=len(data['temperature']), freq='D')
weather_df = pd.DataFrame(data, index=index)
```
- **问题**: 使用**生成的连续日期**，可能与实际数据的时间戳不完全匹配
- **风险**: 如果NetCDF文件中的时间戳不是标准的00:00:00，可能导致时间对齐问题

### 3. 时间筛选逻辑

#### 文件1
```python
# 第153行
time_mask = (time_index_2030 >= start_date) & (time_index_2030 <= end_date)
```
- 使用从NetCDF文件中提取的实际时间戳进行筛选

#### 文件2
```python
# 第203行
time_mask = (self.time_index_year >= start_np) & (self.time_index_year <= end_np)
```
- 使用预先筛选的2030年时间索引进行筛选
- 注意：`start_np` 和 `end_np` 被格式化为 `'%Y-%m-%dT12:00:00'`

### 4. 性能差异

- **文件1**: 每次热浪事件都重新打开文件，**性能较慢**，但数据更准确
- **文件2**: 预先加载数据，**性能更快**，但可能存在时间对齐问题

## 可能导致结果不同的原因

### 1. 时间对齐问题（最可能）
- **文件1**: 使用NetCDF文件中的实际时间戳，时间对齐准确
- **文件2**: 使用生成的连续日期（`pd.date_range`），如果NetCDF文件中的时间戳不是标准的00:00:00，可能导致：
  - 数据错位
  - 日期边界处理不同

### 2. 时间戳格式差异
- 文件2中 `get_data` 方法将日期转换为 `'%Y-%m-%dT12:00:00'` 格式
- 如果NetCDF文件中的时间戳是其他格式（如00:00:00），可能导致筛选结果不同

### 3. 数据精度
- 文件1每次从文件读取，可能保持更高的精度
- 文件2预先加载到内存，可能存在精度损失（虽然通常很小）

## 建议修复方案

### 方案1: 统一使用实际时间戳（推荐）
修改文件2的 `load_climate_data` 函数，使用实际时间戳作为索引：

```python
def load_climate_data(lat, lon, start_date, duration, climate_data):
    duration = int(duration)
    end_date = start_date + timedelta(days=duration - 1)
    
    # 获取数据和时间戳
    data = climate_data.get_data(lat, lon, start_date, end_date)
    time_mask = (climate_data.time_index_year >= start_date) & (climate_data.time_index_year <= end_date)
    actual_time_index = climate_data.time_index_year[time_mask]  # 使用实际时间戳
    
    weather_df = pd.DataFrame(data, index=actual_time_index)
    return weather_df
```

### 方案2: 统一时间格式
确保两个文件使用相同的时间格式进行筛选和索引创建。

## 总结

**主要差异**:
1. 数据加载方式：文件1每次打开文件 vs 文件2预先加载
2. **索引创建方式：文件1使用实际时间戳 vs 文件2使用生成的连续日期**（这是最可能导致结果不同的原因）

**建议**: 修改文件2，使其使用实际时间戳作为DataFrame索引，与文件1保持一致。

